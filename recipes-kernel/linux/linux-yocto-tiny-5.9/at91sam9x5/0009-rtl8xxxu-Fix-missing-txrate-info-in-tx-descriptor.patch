From 26138fb825bbdaf84a60b35f4e7c415b3e9bdb91 Mon Sep 17 00:00:00 2001
From: Chris Chiu <chiu@endlessos.org>
Date: Sun, 25 Oct 2020 18:51:39 +0800
Subject: [PATCH] rtl8xxxu: Fix missing txrate info in tx descriptor

We need to fill in the initial rate (max available rate) in tx
descriptor for data packet.

So we also keep the initial rate value when associated and reset
to 0 while dissociate. Thus we have to create a new field init_rate_desc
in rtl8xxxu_ra_report to achieve the same.

(cherry picked from commit 7f136646ac86bbfabdd7c486c077703a280ef728)
---
 .../net/wireless/realtek/rtl8xxxu/rtl8xxxu.h  |  1 +
 .../wireless/realtek/rtl8xxxu/rtl8xxxu_core.c | 23 ++++++++++++++++++-
 2 files changed, 23 insertions(+), 1 deletion(-)

diff --git a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.h b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.h
index 57a081a465a4..aed4e87494aa 100644
--- a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.h
+++ b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.h
@@ -1276,6 +1276,7 @@ struct rtl8xxxu_ra_report {
 	struct rate_info txrate;
 	u32 bit_rate;
 	u8 desc_rate;
+	u8 init_desc_rate;
 };
 
 struct rtl8xxxu_priv {
diff --git a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
index ef71ada5b9a5..ca91c56f2b55 100644
--- a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
+++ b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
@@ -4761,6 +4761,7 @@ rtl8xxxu_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
                         bit_rate = cfg80211_calculate_bitrate(&rarpt->txrate);
 			rarpt->bit_rate = bit_rate;
                         rarpt->desc_rate = highest_rate;
+			rarpt->init_desc_rate = highest_rate;
 
 			priv->vif = vif;
 			priv->rssi_level = RTL8XXXU_RATR_STA_INIT;
@@ -4781,6 +4782,8 @@ rtl8xxxu_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			val8 |= BEACON_DISABLE_TSF_UPDATE;
 			rtl8xxxu_write8(priv, REG_BEACON_CTRL, val8);
 
+			rarpt->init_desc_rate = 0;
+
 			priv->fops->report_connect(priv, 0, false);
 		}
 	}
@@ -5058,6 +5061,15 @@ rtl8xxxu_fill_txdesc_v1(struct ieee80211_hw *hw, struct ieee80211_hdr *hdr,
 		tx_desc->txdw5 |= cpu_to_le32(TXDESC32_RETRY_LIMIT_ENABLE);
 	}
 
+	// Nothing passed from mac80211 rate control.
+	if (!rate && priv->ra_report.init_desc_rate != 0) {
+                if (ieee80211_is_data_qos(hdr->frame_control)) {
+			struct rtl8xxxu_ra_report *rarpt;
+			rarpt = &priv->ra_report;
+			tx_desc->txdw5 = cpu_to_le32(rarpt->desc_rate);
+                }
+        }
+
 	if (ieee80211_is_data_qos(hdr->frame_control))
 		tx_desc->txdw4 |= cpu_to_le32(TXDESC32_QOS);
 
@@ -5133,6 +5145,15 @@ rtl8xxxu_fill_txdesc_v2(struct ieee80211_hw *hw, struct ieee80211_hdr *hdr,
 		tx_desc40->txdw4 |= cpu_to_le32(TXDESC40_RETRY_LIMIT_ENABLE);
 	}
 
+	// Nothing passed from mac80211 rate control
+        if (!rate && priv->ra_report.init_desc_rate != 0) {
+                if (ieee80211_is_data_qos(hdr->frame_control)) {
+			struct rtl8xxxu_ra_report *rarpt;
+			rarpt = &priv->ra_report;
+			tx_desc40->txdw4 = cpu_to_le32(rarpt->desc_rate);
+                }
+        }
+
 	if (short_preamble)
 		tx_desc40->txdw5 |= cpu_to_le32(TXDESC40_SHORT_PREAMBLE);
 
@@ -5259,7 +5280,6 @@ static void rtl8xxxu_tx(struct ieee80211_hw *hw,
 	else
 		rts_rate = 0;
 
-
 	priv->fops->fill_txdesc(hw, hdr, tx_info, tx_desc, sgi, short_preamble,
 				ampdu_enable, rts_rate);
 
@@ -6800,6 +6820,7 @@ static int rtl8xxxu_probe(struct usb_interface *interface,
 	spin_lock_init(&priv->c2hcmd_lock);
 	INIT_WORK(&priv->c2hcmd_work, rtl8xxxu_c2hcmd_callback);
 	skb_queue_head_init(&priv->c2hcmd_queue);
+	memset(&priv->ra_report, 0, sizeof(struct rtl8xxxu_ra_report));
 
 	usb_set_intfdata(interface, hw);
 
-- 
2.27.0

